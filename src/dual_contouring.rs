//! An implementation of something like dual contouring.
//! Dual contouring examines the voxel grid and looks for edges that cross between different material types.
//! If at least one of the materials is non-opaque, polygons are generated by using vertex data from the adjacent voxels.
//! See the SIGGRAPH paper for more details, but note that this probably isn't precisely a dual contouring implementation.

use cgmath::{Point, Point3, Vector, Vector3};
use std::collections::hash_map;
use std::collections::HashMap;

use voxel_data;

#[allow(missing_docs)]
pub mod material {
  /// This trait provides the functionality required from materials for this algorithm.
  pub trait T : Eq {
    /// Is this material opaque?
    fn is_opaque(&self) -> bool;
  }
}

mod voxel {
  pub use voxel_data::impls::surface_vertex::T::*;
  pub use voxel_data::impls::surface_vertex::*;
}

#[allow(missing_docs)]
pub mod polygon {
  use cgmath::{Point3, Vector3};

  /// The polygon type produced by this algorithm.
  pub struct T<Material> {
    #[allow(missing_docs)]
    pub vertices: [Point3<f32>; 3],
    #[allow(missing_docs)]
    pub normals: [Vector3<f32>; 3],
    #[allow(missing_docs)]
    pub material: Material,
  }
}

/// Run dual contouring on the given SVO, producing a mesh for the location specified, sampling voxels whose size is 2^lg_sample_size.
/// Any missing voxels are generated from the provided mosaic. Each generated polygon is provided to the callback.
pub fn run<Mosaic, Material, F>(
  voxels: &mut voxel_data::tree::T<voxel::T<Material>>,
  generate_from: &Mosaic,
  location: &voxel_data::bounds::T,
  lg_sample_size: i16,
  emit: &mut F,
) where
  Material: material::T + Clone,
  Mosaic: voxel_data::mosaic::T<Material>,
  F: FnMut(polygon::T<Material>),
{
  let bounds_at = |v: &Point3<i32>| {
    voxel_data::bounds::new(v.x, v.y, v.z, lg_sample_size)
  };

  let mut get_voxel = |bounds: &voxel_data::bounds::T| {
    let branch = voxels.get_mut_or_create(bounds);
    match branch {
      &mut voxel_data::tree::Empty => {
        let voxel = voxel_data::impls::surface_vertex::unwrap(voxel::of_field(generate_from, bounds));
        *branch =
          voxel_data::tree::Branch {
            data: Some(voxel.clone()),
            branches: Box::new(voxel_data::tree::Branches::empty()),
          };
        voxel
      },
      &mut voxel_data::tree::Branch { ref mut data, branches: _ }  => {
        match data {
          &mut None => {
            let voxel = voxel::unwrap(voxel::of_field(generate_from, bounds));
            *data = Some(voxel.clone());
            voxel
          },
          &mut Some(ref data) => {
            data.clone()
          },
        }
      },
    }
  };

  let mut coords = Vec::new();
  let mut normals = Vec::new();
  let mut indices = HashMap::new();
  let mut polys = Vec::new();

  assert!(location.lg_size >= lg_sample_size);
  let lg_ratio = location.lg_size - lg_sample_size;
  let num_samples = 1 << lg_ratio;
  let base_position =
    Point3::new(
      location.x << lg_ratio,
      location.y << lg_ratio,
      location.z << lg_ratio,
    );

  for dx in 0..num_samples {
  for dy in 0..num_samples {
  for dz in 0..num_samples {
    let position = base_position.add_v(&Vector3::new(dx, dy, dz));
    let voxel;
    let bounds = bounds_at(&position);
    match get_voxel(&bounds) {
      voxel::T::Surface(v) => voxel = v,
      _ => continue,
    }

    let index = coords.len();
    let vertex = voxel.surface_vertex.to_world_vertex(&bounds);
    let normal = voxel.normal.to_float_normal();
    coords.push(vertex);
    normals.push(normal);
    indices.insert(position, index);

    let mut edge = |
      d_neighbor, // Vector to the neighbor to make an edge toward.
      d1, d2,     // Vector to the voxels adjacent to the edge.
    | {
      let neighbor_position = position.add_v(&d_neighbor);
      let neighbor_material;
      match get_voxel(&bounds_at(&neighbor_position)) {
        voxel::T::Surface(v) => neighbor_material = v.corner,
        voxel::T::Volume(material) => neighbor_material = material,
      }

      if voxel.corner == neighbor_material || voxel.corner.is_opaque() && neighbor_material.is_opaque() {
        // This edge doesn't move from a transparent material to an opaque material, so it doesn't generate visible polys.

        return
      }

      let v1; let v2; let v3; let v4;
      let n1; let n2; let n3; let n4;
      let i1; let i2; let i3; let i4;

      {
        let mut voxel_index = |position: &Point3<i32>| {
          match indices.entry(*position) {
            hash_map::Entry::Occupied(entry) => {
              let i = *entry.get();
              (coords[i], normals[i], i)
            },
            hash_map::Entry::Vacant(entry) => {
              let bounds = bounds_at(position);
              match get_voxel(&bounds) {
                voxel::T::Surface(voxel) => {
                  let i = coords.len();
                  let vertex = voxel.surface_vertex.to_world_vertex(&bounds);
                  let normal = voxel.normal.to_float_normal();
                  coords.push(vertex);
                  normals.push(normal);
                  entry.insert(i);
                  (vertex, normal, i)
                },
                _ => {
                  panic!("Unexpected neighbor {:?}", bounds)
                }
              }
            },
          }
        };

        let (tv1, tn1, ti1) = voxel_index(&position.add_v(&d1).add_v(&d2));
        let (tv2, tn2, ti2) = voxel_index(&position.add_v(&d1));
        let (tv3, tn3, ti3) = (vertex, normal, index);
        let (tv4, tn4, ti4) = voxel_index(&position.add_v(&d2));

        v1 = tv1; v2 = tv2; v3 = tv3; v4 = tv4;
        n1 = tn1; n2 = tn2; n3 = tn3; n4 = tn4;
        i1 = ti1; i2 = ti2; i3 = ti3; i4 = ti4;
      }

      // Put a vertex at the average of the vertices.
      let v_center =
        v1.add_v(&v2.to_vec()).add_v(&v3.to_vec()).add_v(&v4.to_vec()).div_s(4.0);
      let n_center =
        n1.add_v(&n2).add_v(&n3).add_v(&n4).div_s(4.0);

      let i_center = coords.len();
      coords.push(v_center);
      normals.push(n_center);

      if voxel.corner.is_opaque() {
        // The polys are visible from positive infinity.
        polys.push((voxel.corner.clone(), [i2, i1, i_center]));
        polys.push((voxel.corner.clone(), [i3, i2, i_center]));
        polys.push((voxel.corner.clone(), [i4, i3, i_center]));
        polys.push((voxel.corner.clone(), [i1, i4, i_center]));
      } else {
        // The polys are visible from negative infinity.
        polys.push((neighbor_material.clone(), [i1, i2, i_center]));
        polys.push((neighbor_material.clone(), [i2, i3, i_center]));
        polys.push((neighbor_material.clone(), [i3, i4, i_center]));
        polys.push((neighbor_material.clone(), [i4, i1, i_center]));
      }
    };

    edge(
      Vector3::new(1, 0, 0),
      Vector3::new(0, -1, 0),
      Vector3::new(0, 0, -1),
    );

    edge(
      Vector3::new(0, 1, 0),
      Vector3::new(0, 0, -1),
      Vector3::new(-1, 0, 0),
    );

    edge(
      Vector3::new(0, 0, 1),
      Vector3::new(-1, 0, 0),
      Vector3::new(0, -1, 0),
    );
  }}}

  for &(ref material, ref indices) in &polys {
    emit(polygon::T {
      vertices: [coords[indices[0]], coords[indices[1]], coords[indices[2]]],
      normals: [normals[indices[0]], normals[indices[1]], normals[indices[2]]],
      material: material.clone(),
    });
  }
}
